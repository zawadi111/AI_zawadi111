"""
파라미터 최적화 스크립트
1. 설비 조합 최적화 (병목 기반 탐색)
2. AMR 개수 최적화
3. WIP Limit 최적화 (계층적 탐색)
"""

import sim_core
from sim_core import FactoryConfig
import kpi
from config import global_variable
import random
import copy
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple


# ============================================
# Step 1: 설비 좌표 정의 (총 30개)
# ============================================
ALL_MACHINE_POSITIONS = [
    (14,17), (14,15), (14,13), (14,7), (14,5), (14,3),
    (22,17), (22,15), (22,13), (22,7), (22,5), (22,3),
    (30,17), (30,15), (30,13), (30,7), (30,5), (30,3),
    (38,17), (38,15), (38,13), (38,7), (38,5), (38,3),
    (46,17), (46,15), (46,13), (46,7), (46,5), (46,3),
]


# ============================================
# Utility Functions
# ============================================

def run_simulation(machine_counts: Dict[str, int], amr_count: int, wip_limit: int, 
                   seed: int = 42, sim_time: float = 1296000.0) -> float:
    """
    시뮬레이션 실행 및 Profit 반환
    """
    # 좌표 할당
    machine_positions = distribute_positions(machine_counts)
    
    # 시뮬레이션 초기화
    sim_core.reset_sim()
    
    cfg = FactoryConfig(
        sim_time=sim_time,
        seed=seed,
        feed_sequence=("ProdA", "ProdB"),
        machine_counts=machine_counts,
        machine_positions=machine_positions,
        amr_count=amr_count,
    )
    
    global_variable.CURRENT_CFG = cfg
    global_variable.SIM_END = float(cfg.sim_time)
    global_variable.WIP_LIMIT = wip_limit
    global_variable.DISPATCH_POLICY = "eta"
    
    sim_core.build_factory(cfg)
    random.seed(cfg.seed)
    global_variable.FEED_SEQ = list(cfg.feed_sequence)
    global_variable.FEED_IDX = 0
    
    sim_core.schedule(0.0, sim_core.bootstrap_start)
    sim_core.run()
    
    # Profit 계산 (반환값으로 사용)
    profit_value = extract_profit(amr_count, machine_counts)
    
    return profit_value


def distribute_positions(machine_counts: Dict[str, int]) -> Dict[str, List[Tuple[int, int]]]:
    """
    설비 개수에 따라 좌표를 자동으로 할당
    A, B, C, D, E 순서대로 좌표 할당
    """
    positions = {}
    idx = 0
    total_machines = sum(machine_counts.values())
    
    if total_machines > len(ALL_MACHINE_POSITIONS):
        raise ValueError(f"요청한 설비 개수({total_machines})가 할당 가능한 좌표 개수({len(ALL_MACHINE_POSITIONS)})를 초과합니다.")
    
    for stage in ["A", "B", "C", "D", "E"]:
        count = machine_counts.get(stage, 0)
        positions[stage] = ALL_MACHINE_POSITIONS[idx:idx+count]
        idx += count
    
    return positions


def extract_profit(amr_count: int, machine_counts: Dict[str, int]) -> float:
    """
    현재 시뮬레이션 결과에서 Profit 값 추출
    """
    # 설비 투자비 계수
    parameter = {
        "A": 4.0,
        "B": 9.0,
        "C": 8.0,
        "D": 8.0,
        "E": 5.5,
    }
    
    # fac 계산
    fac = sum(count * parameter.get(stage, 0.0) for stage, count in machine_counts.items())
    
    # 산출/투입 개수
    stk = global_variable.STOCKERS.get("STK-01")
    if stk is None:
        return 0.0
    
    output_A = len(stk.list_jobs_A())
    output_B = len(stk.list_jobs_B())
    input_A = global_variable.FEED_COUNT_A
    input_B = global_variable.FEED_COUNT_B
    
    # Profit 계산
    p = 100.0 * min(output_A, output_B) - 5.0 * (input_A + input_B)
    denominator = fac + 0.011 * amr_count
    
    if denominator <= 0:
        return 0.0
    
    raw_profit = p / denominator
    scaled_profit = raw_profit * 100000.0
    
    return scaled_profit


def get_stage_utilization() -> Dict[str, float]:
    """
    각 stage의 평균 가동률 반환 (병목 찾기용)
    """
    stage_info, _, _ = kpi.calc_stage_utilization()
    return {stage: info["util"] for stage, info in stage_info.items()}


# ============================================
# Step 1: 설비 조합 최적화 (병목 기반)
# ============================================

def optimize_machine_counts() -> Tuple[Dict[str, int], float]:
    """
    설비 개수 최적화
    - 초기: A=3, B=3, C=3, D=3, E=3 (총 15개)
    - 병목을 찾아 한 개씩 추가
    - 총 30개까지만 허용
    - 연속 5회 profit 감소 시 종료
    """
    print("\n" + "="*60)
    print("Step 1: 설비 조합 최적화")
    print("="*60)
    
    # 초기 설정
    current_counts = {"A": 3, "B": 3, "C": 3, "D": 3, "E": 3}
    best_profit = -float('inf')
    best_counts = current_counts.copy()
    no_improvement_count = 0
    iteration = 0
    
    amr_count_temp = 9
    wip_limit_temp = 50
    
    while sum(current_counts.values()) < 30:
        iteration += 1
        print(f"\n[Iteration {iteration}] 현재 설비: {current_counts} (총 {sum(current_counts.values())}개)")
        
        # 현재 조합으로 시뮬레이션 실행
        profit = run_simulation(current_counts, amr_count_temp, wip_limit_temp)
        print(f"  Profit: {profit:,.2f}")
        
        # 병목 찾기
        stage_util = get_stage_utilization()
        bottleneck = max(stage_util.keys(), key=lambda s: stage_util[s])
        print(f"  Stage Utilization: {stage_util}")
        print(f"  병목: Stage {bottleneck} ({stage_util[bottleneck]*100:.2f}%)")
        
        # Profit 업데이트
        if profit > best_profit:
            best_profit = profit
            best_counts = current_counts.copy()
            no_improvement_count = 0
            print(f"  ✓ Best Profit 업데이트: {best_profit:,.2f}")
        else:
            no_improvement_count += 1
            print(f"  ✗ 개선 없음 ({no_improvement_count}/5)")
        
        # 종료 조건: 5회 연속 미개선
        if no_improvement_count >= 5:
            print(f"\n5회 연속 미개선으로 종료")
            break
        
        # 병목에 설비 1개 추가
        if sum(current_counts.values()) < 30:
            current_counts[bottleneck] += 1
            print(f"  → Stage {bottleneck}에 설비 1개 추가")
    
    print(f"\n{'='*60}")
    print(f"최적 설비 조합: {best_counts} (총 {sum(best_counts.values())}개)")
    print(f"최적 Profit: {best_profit:,.2f}")
    print(f"{'='*60}")
    
    return best_counts, best_profit


# ============================================
# Step 2: AMR 개수 최적화
# ============================================

def optimize_amr_count(machine_counts: Dict[str, int]) -> Tuple[int, float, Dict[int, float]]:
    """
    최적 설비 조합에서 AMR 개수 최적화
    - 2개부터 시작
    - profit이 계속 증가하는지 확인
    - 연속 3회 미개선 시 종료
    """
    print("\n" + "="*60)
    print("Step 2: AMR 개수 최적화")
    print("="*60)
    
    wip_limit_temp = 50
    best_amr = 2
    best_profit = -float('inf')
    no_improvement_count = 0
    
    amr_profits = {}  # AMR 개수별 Profit 기록
    
    amr_count = 2
    while amr_count <= 20:  # 최대 20개까지 시도
        print(f"\n[AMR {amr_count}개]")
        
        profit = run_simulation(machine_counts, amr_count, wip_limit_temp)
        amr_profits[amr_count] = profit
        print(f"  Profit: {profit:,.2f}")
        
        if profit > best_profit:
            best_profit = profit
            best_amr = amr_count
            no_improvement_count = 0
            print(f"  ✓ Best Profit 업데이트: {best_profit:,.2f}")
        else:
            no_improvement_count += 1
            print(f"  ✗ 개선 없음 ({no_improvement_count}/3)")
        
        # 종료 조건: 3회 연속 미개선
        if no_improvement_count >= 3:
            print(f"\n3회 연속 미개선으로 종료")
            break
        
        amr_count += 1
    
    print(f"\n{'='*60}")
    print(f"최적 AMR 개수: {best_amr}개")
    print(f"최적 Profit: {best_profit:,.2f}")
    print(f"{'='*60}")
    
    return best_amr, best_profit, amr_profits


# ============================================
# Step 3: WIP Limit 최적화 (계층적 탐색)
# ============================================

def optimize_wip_limit(machine_counts: Dict[str, int], amr_count: int) -> Tuple[int, float, Dict[int, float]]:
    """
    최적 설비/AMR에서 WIP Limit 최적화
    - 10 단위로 30~90 탐색 → 5 단위 → 1 단위 정제
    """
    print("\n" + "="*60)
    print("Step 3: WIP Limit 최적화 (계층적 탐색)")
    print("="*60)
    
    wip_profits = {}  # WIP 값별 Profit 기록
    
    # Phase 1: 10 단위 탐색 (30, 40, 50, 60, 70, 80, 90)
    print("\n[Phase 1: 10단위 탐색]")
    coarse_profits = {}
    for wip in range(30, 101, 10):
        print(f"  WIP Limit={wip}...", end=" ", flush=True)
        profit = run_simulation(machine_counts, amr_count, wip)
        coarse_profits[wip] = profit
        wip_profits[wip] = profit
        print(f"Profit: {profit:,.2f}")
    
    # 최적값 근처 찾기
    best_coarse_wip = max(coarse_profits.keys(), key=lambda w: coarse_profits[w])
    best_coarse_profit = coarse_profits[best_coarse_wip]
    print(f"  → Phase 1 최적: WIP={best_coarse_wip}, Profit={best_coarse_profit:,.2f}")
    
    # Phase 2: 5 단위 정제 (최적값 ±15 범위)
    print("\n[Phase 2: 5단위 정제]")
    lower = max(30, best_coarse_wip - 15)
    upper = min(90, best_coarse_wip + 15)
    
    for wip in range(lower, upper + 1, 5):
        if wip in wip_profits:  # 이미 탐색한 값 스킵
            continue
        print(f"  WIP Limit={wip}...", end=" ", flush=True)
        profit = run_simulation(machine_counts, amr_count, wip)
        wip_profits[wip] = profit
        print(f"Profit: {profit:,.2f}")
    
    best_5unit_wip = max(wip_profits.keys(), key=lambda w: (wip_profits[w], w))
    best_5unit_profit = wip_profits[best_5unit_wip]
    print(f"  → Phase 2 최적: WIP={best_5unit_wip}, Profit={best_5unit_profit:,.2f}")
    
    # Phase 3: 1 단위 정제 (최적값 ±5 범위)
    print("\n[Phase 3: 1단위 정제]")
    lower = max(30, best_5unit_wip - 5)
    upper = min(90, best_5unit_wip + 5)
    
    for wip in range(lower, upper + 1, 1):
        if wip in wip_profits:  # 이미 탐색한 값 스킵
            continue
        print(f"  WIP Limit={wip}...", end=" ", flush=True)
        profit = run_simulation(machine_counts, amr_count, wip)
        wip_profits[wip] = profit
        print(f"Profit: {profit:,.2f}")
    
    best_wip = max(wip_profits.keys(), key=lambda w: (wip_profits[w], w))
    best_profit = wip_profits[best_wip]
    
    print(f"\n{'='*60}")
    print(f"최적 WIP Limit: {best_wip}")
    print(f"최적 Profit: {best_profit:,.2f}")
    print(f"{'='*60}")
    
    return best_wip, best_profit, wip_profits


# ============================================
# Final Result
# ============================================

def print_final_results(machine_counts: Dict[str, int], amr_count: int, wip_limit: int):
    """
    최적 조합으로 최종 시뮬레이션 실행 및 결과 출력
    """
    print("\n" + "="*60)
    print("최종 시뮬레이션 실행 (최적 조합)")
    print("="*60)
    
    machine_positions = distribute_positions(machine_counts)
    
    sim_core.reset_sim()
    
    cfg = FactoryConfig(
        sim_time=1296000.0,
        seed=42,
        feed_sequence=("ProdA", "ProdB"),
        machine_counts=machine_counts,
        machine_positions=machine_positions,
        amr_count=amr_count,
    )
    
    global_variable.CURRENT_CFG = cfg
    global_variable.SIM_END = float(cfg.sim_time)
    global_variable.WIP_LIMIT = wip_limit
    global_variable.DISPATCH_POLICY = "eta"
    
    sim_core.build_factory(cfg)
    random.seed(cfg.seed)
    global_variable.FEED_SEQ = list(cfg.feed_sequence)
    global_variable.FEED_IDX = 0
    
    sim_core.schedule(0.0, sim_core.bootstrap_start)
    sim_core.run()
    
    # 결과 출력
    print(f"\n설비 조합: {machine_counts} (총 {sum(machine_counts.values())}개)")
    print(f"AMR 개수: {amr_count}개")
    print(f"WIP Limit: {wip_limit}")
    
    # 설비 좌표 출력
    print(f"\n{'='*60}")
    print("설비 배치 좌표")
    print(f"{'='*60}")
    for stage in ["A", "B", "C", "D", "E"]:
        positions = machine_positions.get(stage, [])
        if positions:
            print(f"Stage {stage}: {len(positions)}개")
            for i, pos in enumerate(positions, 1):
                print(f"  {stage}-{i}: {pos}")
    
    kpi.information()
    kpi.profit(amr_count=amr_count, machine_counts=machine_counts)
    kpi.print_amr_utilization()
    kpi.print_stage_bottleneck()


def plot_results(amr_profits: Dict[int, float], wip_profits: Dict[int, float]):
    """
    AMR 개수와 WIP Limit에 따른 Profit 변화 그래프
    """
    fig, axes = plt.subplots(1, 2, figsize=(14, 5))
    
    # AMR 개수 그래프
    amr_counts = sorted(amr_profits.keys())
    amr_profit_values = [amr_profits[c] for c in amr_counts]
    
    axes[0].plot(amr_counts, amr_profit_values, 'b-o', linewidth=2, markersize=8)
    axes[0].set_xlabel('AMR', fontsize=12, fontweight='bold')
    axes[0].set_ylabel('Profit', fontsize=12, fontweight='bold')
    axes[0].set_title('Profit for AMR number', fontsize=13, fontweight='bold')
    axes[0].grid(True, alpha=0.3)
    axes[0].set_xticks(amr_counts)
    
    # WIP Limit 그래프
    wip_limits = sorted(wip_profits.keys())
    wip_profit_values = [wip_profits[w] for w in wip_limits]
    
    axes[1].plot(wip_limits, wip_profit_values, 'r-s', linewidth=2, markersize=8)
    axes[1].set_xlabel('WIP Limit', fontsize=12, fontweight='bold')
    axes[1].set_ylabel('Profit', fontsize=12, fontweight='bold')
    axes[1].set_title('Profit for WIP Limit', fontsize=13, fontweight='bold')
    axes[1].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('optimization_results.png', dpi=300, bbox_inches='tight')
    print("\n그래프 저장됨: optimization_results.png")
    plt.show()


# ============================================
# Main
# ============================================

if __name__ == "__main__":
    print("\n" + "="*60)
    print("파라미터 최적화 시작")
    print("="*60)
    
    # Step 1: 설비 조합 최적화
    best_machines, best_machine_profit = optimize_machine_counts()
    
    # Step 2: AMR 개수 최적화
    best_amr, best_amr_profit, amr_profits = optimize_amr_count(best_machines)
    
    # Step 3: WIP Limit 최적화
    best_wip, best_wip_profit, wip_profits = optimize_wip_limit(best_machines, best_amr)
    
    # 최종 결과 출력
    print_final_results(best_machines, best_amr, best_wip)
    
    # 그래프 출력
    print("\n그래프 생성 중...")
    plot_results(amr_profits, wip_profits)
    
    print("\n" + "="*60)
    print("최적화 완료!")
    print("="*60)